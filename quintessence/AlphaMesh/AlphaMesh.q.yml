methods:


  - name: process
    type: AllegroFlare::TileMaps::TileMap<bool>
    static: true
    parameters:
      - name: bitmap
        type: ALLEGRO_BITMAP*
        default_argument: nullptr
      - name: num_rows
        type: int
        default_argument: 16
      - name: num_columns
        type: int
        default_argument: 16
    guards: [ bitmap, (num_rows >= 2), (num_columns >= 2) ]
    body: |
      AllegroFlare::TileMaps::TileMap<bool> result;
      result.resize(num_columns, num_rows);
      result.initialize();

      int bitmap_width = al_get_bitmap_width(bitmap);
      int bitmap_height = al_get_bitmap_height(bitmap);

      int cell_width_in_pixels = bitmap_width / num_columns;
      int cell_height_in_pixels = bitmap_height / num_rows;

      // HERE: process the image
      al_lock_bitmap(bitmap, ALLEGRO_PIXEL_FORMAT_ANY, ALLEGRO_LOCK_READONLY);
      const float ALPHA_THRESHOLD = 0.0001f;

      for (int tile_y=0; tile_y<num_rows; tile_y++)
      {
         for (int tile_x=0; tile_x<num_columns; tile_x++)
         {
            for (int pixel_y=0; pixel_y<cell_height_in_pixels; pixel_y++)
            {
               for (int pixel_x=0; pixel_x<cell_width_in_pixels; pixel_x++)
               {
                  int x_pos = tile_x * cell_width_in_pixels;
                  int y_pos = tile_y * cell_height_in_pixels;
                  ALLEGRO_COLOR p = al_get_pixel(bitmap, x_pos + pixel_x, y_pos + pixel_y);
                  if (p.a <= ALPHA_THRESHOLD) result.set_tile(tile_x, tile_y, false);
                  else result.set_tile(tile_x, tile_y, true); // Is this necessary?
               }
            }
         }
      }

      al_unlock_bitmap(bitmap);

      return result;


dependencies:


  - symbol: AllegroFlare::TileMaps::TileMap
    headers: [ AllegroFlare/TileMaps/TileMap.hpp ]
  - symbol: ALLEGRO_BITMAP
    headers: [ allegro5/allegro.h ]


